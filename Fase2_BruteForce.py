"""
================================================================================
Phase 1 (Part B): Validation of Cracking Logic (Sanity Check)
================================================================================

Script Objective:
-----------------
This script is the counterpart to 'Fase1_create_test_case.py'. Its purpose is
to verify that our cracking "engine" works correctly. It uses the 'salt' and
'ciphertext' generated by the previous script to attempt to find the password
we already know ("giovanni0@").

Operation:
----------
1.  Uses the predefined 'salt' and 'ciphertext' values, copied from the output
    of the script 'Fase1_create_test_case.py'.
2.  Defines a 'decrypt' function that encapsulates the verification logic for a
    single password:
    a. Takes a candidate password.
    b. Runs the same KDF process (PBKDF2) to derive a key.
    c. Attempts to decrypt the 'ciphertext' with the obtained key.
    d. Uses the 'try...except' mechanism to handle success or failure: if
       decryption succeeds, it returns True; otherwise, it catches the 
       'InvalidToken' exception and returns False.
3.  Simulates a small brute force attack:
    a. Uses a dictionary and restricted character sets, which are guaranteed
       to include the components of our test password ("giovanni", "0", "@").
    b. Iterates through all possible combinations.
    c. For each combination, calls the 'decrypt' function.
4.  Stops as soon as the password is found and prints a success message.

Role in the Methodological Process:
-----------------------------------
This is the proof of concept. The success of this script gives us maximum
confidence in our base code. It confirms that if we provide the correct password
to our mechanism, it will identify it. Any failure in the real attack will not
be due to a bug in this logic, but rather an error in the generation of 
candidate passwords (i.e., a wrong hypothesis about the password structure).

"""

# Import of necessary libraries.
import base64
import time # To measure the test duration.
from cryptography.fernet import Fernet, InvalidToken
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC


# --- 1. Definition of the Test Target ---
# These values must be copied from the output of 'Fase1_create_test_case.py'.
# They are our 'ciphertext' and the 'salt' for which we know the solution.
salt = b'N4\x80\xf6?>\x953\x1e+\x8e\xf1v\xe5x?'
ciphertext = b'gAAAAABo59OFDb9D3CHY-kcmhLbBaEYB5Bh5NCKaMxK1OevbcsdkpbOB4DHOdWmuQAgr14oHKhGXLhP8PCiF2POVeXLx4NBZEYhSSC0bfohNwfDI6CM2-KiOzoCERMEtDEBPo2rm5EQc'


# --- 2. Password Verification Function ---
# This function is the core of our cracker. It is designed to be
# reusable and test a single password.
def decrypt(passwd_bytes):
    """
    Attempts to decrypt the global ciphertext using the provided password.

    Args:
        passwd_bytes (bytes): The candidate password to test, in bytes format.

    Returns:
        bool: True if the password is correct, False otherwise.
    """
    try:
        # 2.a. Recreates the KDF with the exact same parameters used for encryption.
        # It is crucial that every parameter (algorithm, length, salt, iterations)
        # is exactly the same.
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        # 2.b. Derives and encodes the key from the candidate password.
        key = base64.urlsafe_b64encode(kdf.derive(passwd_bytes))
        
        # 2.c. Attempts decryption.
        f = Fernet(key)
        plaintext = f.decrypt(ciphertext)
        
        # 2.d. If the code reaches this point, decryption was successful!
        print("\n" + "="*50)
        print(f"[SUCCESS] PASSWORD FOUND: {passwd_bytes.decode('utf-8')}")
        print(f"[SUCCESS] PLAINTEXT: {plaintext.decode('utf-8')}")
        print("="*50)
        return True
        
    except InvalidToken:
        # This error is expected for every wrong password. It is raised
        # by Fernet when the key is incorrect (integrity check failure).
        # We simply return False and continue.
        return False


# --- 3. Test Brute Force Logic ---
# We simulate an attack on a very small set of possibilities,
# ensuring the solution is present.

# 3.a. We define the components to include our password "giovanni0@"
test_dictionary = ["gatto", "pippo", "giovanni"] 
test_specials = ['$', '#', '@']
test_numbers = ['1', '2', '0']

# 3.b. We define the password schema we know is correct for our case.
test_pattern = "{word}{num}{spec}" # Corresponds to "giovanni" + "0" + "@"

print("Starting cracker validation test...")
start_time = time.time()
password_found = False
attempts = 0

# 3.c. Nested loops to generate every combination.
for word in test_dictionary:
    if password_found: break # If password is found, break the outermost loop.
    for num in test_numbers:
        if password_found: break
        for spec in test_specials:
            # Constructs the candidate password using our schema.
            guess_str = test_pattern.format(word=word, num=num, spec=spec)
            guess_bytes = guess_str.encode('utf-8') # Converts to bytes for the function.
            
            attempts += 1
            print(f"Attempt #{attempts}: {guess_str}")
            
            # Calls the verification function.
            if decrypt(guess_bytes):
                password_found = True
                break # Breaks the innermost loop.

# --- 4. Final Test Results ---
end_time = time.time()
duration = end_time - start_time

print("\n--- Validation Test Summary ---")
if password_found:
    print("[RESULT] SUCCESS: The cracker logic is correct and working.")
else:
    print("[RESULT] FAILURE: There is an error in the 'decrypt' function or the base logic.")

print(f"Total passwords tested: {attempts}")
print(f"Time elapsed: {duration:.2f} seconds")
print("="*45)